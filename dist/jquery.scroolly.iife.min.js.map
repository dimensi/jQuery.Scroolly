{"version":3,"file":"jquery.scroolly.iife.min.js","sources":["../src/jquery.scroolly.js"],"sourcesContent":["import $ from 'jquery'\n\nconst scroolly = {\n  options: {\n    timeout: null,\n    meter: $('.scroolly'),\n    body: document,\n  },\n  theCSSPrefix: '',\n  theDashedCSSPrefix: '',\n  isMobile: false,\n  isInitialized: false,\n  //        requestAnimFrame: null,\n  //        cancelAnimFrame: null,\n\n  animFrame: null,\n  direction: 0,\n  scrollTop: 0,\n  scrollCenter: 0,\n  scrollBottom: 0,\n  docHeight: 0,\n  docMiddle: 0,\n  winHeight: $(window).height(),\n};\n\nscroolly.scrollLayout = {\n  //  TSB - top screen border\n  //        topbarSearchForm:{\n  //            element: searchFormTop,\n  //            rules:[\n  //                {\n  //                    from: 0, // top border of the rule region\n  //                    to: 'finish', // bottom border of the rule region\n  //                          // if ommited then set to 'from' of the following rule\n  //                          // if there is no following rule set to 'bottom'\n  //                    minWith: 0, // min viewport width for the rule to apply\n  //                    maxWidth: 'infinity', // max viewport width for the rule to apply\n  //                    direction: 0, // 0 - ignored, >0 - forward, <0 - backward\n  //                    alias: 'top', // region alias\n  //                    css: null,//{'display': 'none'}, // css to apply when TSB enters rule region\n  //                    cssFrom: {'border': '0px solid #000000'},\n  //                    cssTo: {'border': '10px solid #eeeeee'},\n  //                    addClass: null,   // $.addClass() param value to add classes when TSB enters rule region\n  //                    removeClass: null,    // $.removeClass() param value to remove classes when TSB enters rule region\n  //                    onCheckIn: function(element){ // callback on TSB enters rule region\n  //                        element\n  //                        .hide('fade', 100);\n  //                        searchInputMain.val(searchInputTop.val());\n  //                    },\n  //                    onCheckOut: function(element){} // callback on TSB leaves rule region\n  //                    onTopIn: function(element){}  // callback on TSB enters rule region from the top border\n  //                    onTopOut: function(element){}  // callback on TSB leaves rule region from the top border\n  //                    onBottomIn: function(element){}  // callback on TSB enters rule region from the bottom border\n  //                    onBottomOut: function(element){}  // callback on TSB leaves rule region from the bottom border\n  //                    onScroll: function(element, offset, length){}  // callback on scroll event while TSB is in the rule region\n  //                                      // offset - is the offset (px) of the TSB from the rule region top border\n  //                                      // length - is the rule region size (px)\n  //                    onDirectionChanged: function(element, direction){}\n  //                },\n  //                {\n  //                    from: searchFormMain.offset().top,\n  //                    alias: 'searchform',\n  //                    css: null,//{'display': 'block'},\n  //                    addClass: null,\n  //                    removeClass: null,\n  //                    onCheckIn: function(element){\n  //                        element.show('fade', 300);\n  //                        searchInputTop.val(searchInputMain.val());\n  //                    },\n  //                    onCheckOut: function(element){}\n  //                }\n  //            ]\n  //        }\n};\n\nscroolly._isObject = function (val) {\n  return typeof val === 'object';\n};\n\nscroolly._isArray = function (val) {\n  return val instanceof Array;\n};\n\nscroolly._isNumber = function (val) {\n  return val instanceof Number || typeof val === 'number';\n};\n\nscroolly._isString = function (val) {\n  return val instanceof String || typeof val === 'string';\n};\n\nscroolly._default = function (obj, key, defaultValue) {\n  if (defaultValue === undefined) {\n    defaultValue = null;\n  }\n  var parts = (key + '').split('.');\n  if (obj && (scroolly._isObject(obj) || scroolly._isArray(obj))) {\n    var root = obj,\n      part;\n    for (var i in parts) {\n      part = parts[i];\n      if (\n        (scroolly._isObject(root) || scroolly._isArray(root)) &&\n        root[part] !== undefined\n      ) {\n        root = root[part];\n      } else {\n        return defaultValue;\n      }\n    }\n    return root;\n  }\n\n  return defaultValue;\n  //        return _.empty(obj[key])?defaultValue:obj[key];\n};\n\n/**\n * Parse rule boundry\n * @param {string} boundry - '[anchor] [offset] = [vieport anchor] [offset]'\n * @return {object} - parsed boundry\n */\nscroolly.parseCoords = function (boundry) {\n  var strings = boundry.split(/\\s*=\\s*/),\n    coordRel = strings[0] || 'doc-top',\n    parsedCoordRel = scroolly.parseCoord(coordRel),\n    coordVP = strings[1] || parsedCoordRel.anchor,\n    parsedCoordVP = scroolly.parseCoord(coordVP);\n\n  return [parsedCoordRel, parsedCoordVP];\n};\n\n/**\n * Parse rule coord part\n * @param {string} coord - '[anchor] [offset]'\n * @return {object} - parsed boundry\n */\nscroolly.parseCoord = function (coord) {\n  var reAnchor = /((vp|doc|el|con)-)?(top|center|bottom)?/i,\n    reOffsetStr = '(\\\\+|-)?\\\\s*(\\\\d+)(\\\\%|vp|doc|el|con)?',\n    reOffset = new RegExp(reOffsetStr, 'gi'),\n    mA = coord.match(reAnchor),\n    mO = coord.match(reOffset);\n\n  if (!mA && !mO) {\n    return false;\n  }\n\n  var subject = mA[1] ? mA[2] : 'vp',\n    anchor = mA[3] || 'top',\n    offsets = [];\n\n  if (mO) {\n    reOffset = new RegExp(reOffsetStr, 'i');\n    var offsetStr, mO2, sign, offset, offsetSubject;\n\n    for (var i = 0; i < mO.length; i++) {\n      offsetStr = mO[i];\n      mO2 = offsetStr.match(reOffset);\n      sign = mO2[1] && mO2[1] === '-' ? -1 : 1;\n      offset = (mO2[2] && parseInt(mO2[2]) * sign) || 0;\n      offsetSubject = 'px';\n\n      if (mO2[3]) {\n        offsetSubject = mO2[3] === '%' ? subject : mO2[3];\n      }\n\n      offsets.push({\n        offset: offset,\n        subject: offsetSubject,\n      });\n    }\n  }\n  return {\n    original: coord,\n    subject: subject,\n    anchor: anchor,\n    offsets: offsets,\n  };\n};\n\n/**\n * Calculate coord position towards top of the document\n * @param {string} coord - '[anchor] [offset]'\n * @param {jQuery(element)} $element\n * @param {jQuery(container)} $container\n * @return {object} - parsed boundry\n */\nscroolly.calculateCoord = function (coord, $element, $container) {\n  if (scroolly._isString(coord)) {\n    coord = scroolly.parseCoord(coord);\n  }\n\n  var subjectCoord = 0;\n  if ('vp' === coord.subject) {\n    switch (coord.anchor) {\n      case 'top':\n        subjectCoord = scroolly.scrollTop;\n        break;\n      case 'center':\n        subjectCoord = scroolly.scrollCenter;\n        break;\n      case 'bottom':\n        subjectCoord = scroolly.scrollBottom;\n        break;\n    }\n  } else if ('doc' === coord.subject) {\n    switch (coord.anchor) {\n      case 'top':\n        subjectCoord = 0;\n        break;\n      case 'center':\n        subjectCoord = scroolly.docMiddle;\n        break;\n      case 'bottom':\n        subjectCoord = scroolly.docHeight;\n    }\n  } else {\n    var $subject = 'con' === coord.subject ? $container : $element,\n      subjectHeight = $subject.outerHeight(),\n      subjectTop = $subject.offset().top,\n      subjectBottom = subjectTop + subjectHeight,\n      subjectCenter = subjectTop + Math.floor(subjectHeight / 2);\n\n    switch (coord.anchor) {\n      case 'top':\n        subjectCoord = subjectTop;\n        break;\n      case 'center':\n        subjectCoord = subjectCenter;\n        break;\n      case 'bottom':\n        subjectCoord = subjectBottom;\n        break;\n    }\n  }\n\n  var i, o, subjectOffset, relativeHeight;\n  for (i = 0; i < coord.offsets.length; i++) {\n    o = coord.offsets[i];\n    subjectOffset = o.offset;\n\n    if ('px' !== o.subject) {\n      relativeHeight = 0;\n      switch (o.subject) {\n        case 'vp':\n          relativeHeight = scroolly.winHeight;\n          break;\n        case 'doc':\n          relativeHeight = scroolly.docHeight;\n          break;\n        case 'el':\n          relativeHeight = $element.outerHeight();\n          break;\n        case 'con':\n          relativeHeight = $container.outerHeight();\n          break;\n      }\n\n      subjectOffset = Math.ceil((o.offset / 100) * relativeHeight);\n      //                console.log(subjectOffset);\n    }\n    subjectCoord += subjectOffset;\n  }\n\n  //        console.dir({'computed':{ags: arguments, res: subjectCoord}});\n\n  return subjectCoord;\n};\n\n/**\n * Calculate how much we should scroll down till boundry\n * @param {Object} coords\n * @param {$(DOMnode)} $element\n * @param {$(DOMnode)} $container\n * @returns {integer} how much we should scroll down till boundry\n */\nscroolly.cmpCoords = function (coords, $element, $container) {\n  return (\n    scroolly.calculateCoord(coords[0], $element, $container) -\n    scroolly.calculateCoord(coords[1], $element, $container)\n  );\n};\n\n/**\n * Check if rule is active\n * @param {object} rule\n * @return {boolean}\n */\nscroolly.isRuleInActiveWidthRange = function (rule) {\n  var fromX = scroolly._default(rule, 'minWidth', 0),\n    toX = scroolly._default(rule, 'maxWidth', 'infinity'),\n    meter = scroolly._default(scroolly.options, 'meter'),\n    width = $(window).width(),\n    minWidthScrolly,\n    maxWidthScrolly,\n    checkinWidth;\n\n  if (meter.length) {\n    minWidthScrolly = meter.length ? parseInt(meter.css('min-width')) : 0;\n    maxWidthScrolly = meter.length ? meter.css('max-width') : 'none';\n    maxWidthScrolly =\n      maxWidthScrolly === 'none' ? 'infinity' : parseInt(maxWidthScrolly);\n    checkinWidth =\n      fromX <= minWidthScrolly &&\n      (toX === 'infinity' || toX >= maxWidthScrolly);\n\n    return checkinWidth;\n  }\n\n  return fromX < width && (toX === 'infinity' || toX >= width);\n};\n\n/**\n * Check if rule is active\n *\n * @param {object} rule\n * @param {$(DOMnode)} $element\n * @param {$(DOMnode)|String} $container description\n * @returns {boolean|object} false if rule is not active or scrolling params instead\n * {\n *      offset: how many pixels since top boundry were scrolled\n *      length: total length of the region in pisels\n * }\n */\nscroolly.isRuleActive = function (rule, $element, $container) {\n  var checkinWidth = scroolly.isRuleInActiveWidthRange(rule);\n  if (!checkinWidth) {\n    return false;\n  }\n\n  var ruleDirection = scroolly._default(rule, 'direction', 0),\n    scrollDirection = scroolly.direction;\n\n  if (\n    ruleDirection &&\n    ((ruleDirection > 0 && scrollDirection < 0) ||\n      (ruleDirection < 0 && scrollDirection >= 0))\n  ) {\n    return false;\n  }\n\n  var fromY = scroolly._default(rule, 'from', '0'),\n    toY = scroolly._default(rule, 'to', 'finish');\n\n  var toTop = scroolly.cmpCoords(fromY, $element, $container);\n  if (toTop > 0) {\n    return false;\n  }\n\n  var toBottom = scroolly.cmpCoords(toY, $element, $container);\n  if (toBottom <= 0) {\n    return false;\n  }\n\n  return {\n    offset: -toTop,\n    length: toBottom - toTop,\n  };\n};\n\n/**\n * Helper and polyfill for non-ECMA5 compliant browsers to get layout length\n * @returns {number} length of scrollLayout\n */\nscroolly.getScrollLayoutLength = function () {\n  return !Object.keys\n    ? $.map(scroolly.scrollLayout, function () {\n        return 1;\n      }).length\n    : Object.keys(scroolly.scrollLayout).length;\n};\n\n/**\n * Add ellement with its rules to scroll layout\n * See the commented sample above for the rules syntax\n *\n * @param {string} id\n * @param {$(DOMnode)} $element\n * @param {array} rules\n * @param {$(DOMnode)} $container description\n */\nscroolly.addItem = function (id, $element, rules, $container) {\n  if (!$element.length) {\n    return false;\n  }\n\n  $container = $container || 'self';\n\n  var rule, isAbsolute, fromY, toY, fromCss, toCss, cssOnScroll;\n\n  cssOnScroll = function (element, offset, length, rule) {\n    var progress = offset / length,\n      fromCss = scroolly._default(rule, 'cssFrom'),\n      toCss = scroolly._default(rule, 'cssTo'),\n      css = {},\n      fromProp,\n      toProp;\n\n    for (var property in fromCss) {\n      fromProp = fromCss[property];\n      toProp = scroolly._default(toCss, property, fromProp);\n      css[property] = scroolly.getTransitionValue(fromProp, toProp, progress);\n    }\n\n    element.css(scroolly.extendCssWithPrefix(css));\n  };\n\n  for (var i in rules) {\n    rule = rules[i];\n\n    isAbsolute = !$container; //?true:false;\n\n    fromY = scroolly._default(rule, 'from', 'doc-top');\n\n    if (scroolly._isString(fromY) || scroolly._isNumber(fromY)) {\n      fromY = scroolly.parseCoords('' + fromY);\n      rule.from = fromY;\n    }\n\n    toY = scroolly._default(rule, 'to', 'doc-bottom');\n\n    if (scroolly._isString(toY) || scroolly._isNumber(toY)) {\n      toY = scroolly.parseCoords('' + toY);\n\n      rule.to = toY;\n    }\n\n    fromCss = scroolly._default(rule, 'cssFrom');\n    toCss = scroolly._default(rule, 'cssTo');\n\n    if (fromCss && toCss) {\n      rule.cssOnScroll = cssOnScroll;\n    }\n  }\n  if ($element.length > 1) {\n    $element.each(function (i) {\n      var clonedRules = [],\n        rule,\n        clonedRule,\n        $con = null;\n\n      for (var j = 0; j < rules.length; j++) {\n        rule = rules[j];\n        clonedRule = {};\n        $.extend(clonedRule, rule);\n        clonedRules.push(clonedRule);\n      }\n\n      if ($container) {\n        if ($container === 'self') {\n          $con = $container;\n        } else {\n          $con =\n            $container.length > 1 && i < $container.length\n              ? $($container[i])\n              : $container;\n        }\n      }\n\n      scroolly.addItem(id + '-' + i, $(this), clonedRules, $con);\n    });\n\n    return true;\n  }\n  var item = scroolly._default(scroolly.scrollLayout, id);\n  if (item) {\n    item.rules.concat(rules);\n  } else {\n    scroolly.scrollLayout[id] = {\n      element: $element,\n      container: $container,\n      rules: rules,\n    };\n  }\n  return true;\n};\n\nscroolly.factory = function ($element, rules, $container, id) {\n  scroolly.init();\n\n  if (!$element.length) {\n    return false;\n  }\n\n  if (!rules) {\n    return false;\n  }\n\n  id = id || $element[0].tagName + '_' + scroolly.getScrollLayoutLength();\n  scroolly.addItem(id, $element, rules, $container, false);\n};\n\n/**\n * Fix DOM element in NON-Responsive (non viewport width dependent) layout.\n * When applied, DOMnode is fixed when TSB is within\n * (node's top border - offsetTop) and ($bottomContainer's bottom border - offsetBottom)\n * and unfixed when TSB is out of the region\n *\n * @param string id\n * @param $(DOMnode) $element\n * @param object params: {\n *      $bottomContainer - $(DOMnode) which restricts fix from the bottom,\n *          '<body>' by default,\n *          'next' means the next dom sibling $element.next()\n *          'parent' means $element.parent()\n *      mode - sets the mode of adding needed white space to $bottomContainer\n *          when $element is fixed\n *          'margin' means margin-top=$element.height() wil be added to $bottomContainer\n *          'padding' means padding-top=$element.height() wil be added to $bottomContainer\n *      offsetTop - top offset that is left before fixed element when fixed\n *      offsetBottom - bottom offset left before $bottomContainer\n *      minWidth, maxWidth - viewport width (px) boundries\n *          is used within stickItemXY for responsive layouts\n *          0, 'infinity' by default\n *      static -\n * }\n */\nscroolly.stickItem = function (\n  id,\n  $element,\n  params /*$bottomContainer, mode, offsetTop, offsetBottom*/\n) {\n  scroolly.stickItemXY(\n    id,\n    $element,\n    params instanceof Array ? params : [params]\n  );\n};\n\n/**\n * Fix DOM element in NON-Responsive (non viewport width dependent) layout.\n * When applied, DOMnode is fixed when TSB is within\n * (node's top border - offsetTop) and ($bottomContainer's bottom border - offsetBottom)\n * and unfixed when TSB is out of the region\n *\n * @param string id\n * @param $(DOMnode) $element\n * @param array params - array of objects described in stickItem()\n */\nscroolly.stickItemXY = function (\n  id,\n  $element,\n  params /*$bottomContainer, mode, offsetTop, offsetBottom*/\n) {\n  params = params || [];\n  var rules = [],\n    xRange,\n    $bottomContainer,\n    mode,\n    offsetTop,\n    offsetBottom,\n    minWidth,\n    maxWidth,\n    isStatic;\n  for (var x in params) {\n    xRange = params[x];\n    $bottomContainer = scroolly._default(\n      xRange,\n      '$bottomContainer',\n      $('body')\n    );\n    mode = scroolly._default(xRange, 'mode');\n    offsetTop = scroolly._default(xRange, 'offsetTop', 0);\n    offsetBottom = scroolly._default(xRange, 'offsetBottom', 0);\n    minWidth = scroolly._default(xRange, 'minWidth', 0);\n    maxWidth = scroolly._default(xRange, 'maxWidth', 'infinity');\n    isStatic = scroolly._default(xRange, 'static', false);\n\n    if ('next' === $bottomContainer) {\n      mode = mode || 'margin';\n      $bottomContainer = $($element).next();\n    } else if ('parent' === $bottomContainer || !$bottomContainer) {\n      mode = mode || 'padding';\n      $bottomContainer = $($element).parent();\n    }\n\n    if (!isStatic) {\n      rules.push({\n        source: 'sticky',\n        alias: 'top',\n        minWidth: minWidth,\n        maxWidth: maxWidth,\n        offsetTop: offsetTop,\n        offsetBottom: offsetBottom,\n        bottomContainer: $bottomContainer,\n        mode: mode,\n      });\n      rules.push({\n        source: 'sticky',\n        alias: 'fixed',\n        minWidth: minWidth,\n        maxWidth: maxWidth,\n        offsetTop: offsetTop,\n        offsetBottom: offsetBottom,\n        bottomContainer: $bottomContainer,\n        mode: mode,\n      });\n\n      rules.push({\n        source: 'sticky',\n        alias: 'bottom',\n        minWidth: minWidth,\n        maxWidth: maxWidth,\n        offsetTop: offsetTop,\n        offsetBottom: offsetBottom,\n        bottomContainer: $bottomContainer,\n        mode: mode,\n        //                    from: offset_2,\n        //                    css: {'position': 'absolute', 'top':(offset_2+offsetTop)+'px'}\n      });\n    } else {\n      rules.push({\n        source: 'sticky',\n        alias: 'static',\n        minWidth: minWidth,\n        maxWidth: maxWidth,\n        bottomContainer: $bottomContainer,\n      });\n    }\n  }\n\n  scroolly.addItem(id, $($element), rules);\n};\n\n/**\n * This function calculates all rules boundries when browser is resized and\n * enters new width range. We cannot precalculate all sizes as during window\n * resize some element are resized.\n *\n * @param {$(DOMnode)} $element\n * @param {object} rule - single rule\n * @returns {object} - recalculated rule\n */\nscroolly.processStickyItemRange = function ($element, rule) {\n  rule = rule || {};\n\n  var $bottomContainer = scroolly._default(\n      rule,\n      'bottomContainer',\n      $('body')\n    ),\n    mode = scroolly._default(rule, 'mode'),\n    offsetTop = scroolly._default(rule, 'offsetTop', 0),\n    offsetBottom = scroolly._default(rule, 'offsetBottom', 0),\n    itemHeight =\n      parseInt($element.css('margin-top')) +\n      $element.height() +\n      parseInt($element.css('margin-bottom'));\n\n  if ($element.css('box-sizing') === 'border-box') {\n    itemHeight +=\n      parseInt($element.css('padding-top')) +\n      parseInt($element.css('padding-bottom'));\n  }\n\n  var bottomContainerHeight =\n    parseInt($bottomContainer.css('margin-top')) +\n    $bottomContainer.height() +\n    parseInt($bottomContainer.css('margin-bottom'));\n  if ($bottomContainer.css('box-sizing') === 'border-box') {\n    bottomContainerHeight +=\n      parseInt($bottomContainer.css('padding-top')) +\n      parseInt($bottomContainer.css('padding-bottom'));\n  }\n\n  var offset_1 = Math.round(\n      $element.offset().top - parseInt($element.css('margin-top'))\n    ),\n    offset_2 = Math.round(\n      $bottomContainer.offset().top +\n        (bottomContainerHeight - itemHeight - offsetBottom)\n    );\n\n  switch (rule.alias) {\n    case 'top':\n      rule.from = 0;\n      rule.to = offset_1 - offsetTop;\n      rule.css = { position: 'absolute', top: offset_1 + 'px' };\n      rule.itemHeight = itemHeight;\n      break;\n\n    case 'fixed':\n      rule.from = offset_1 - offsetTop;\n      rule.to = offset_2;\n      rule.css = { position: 'fixed', top: offsetTop + 'px' };\n      rule.itemHeight = itemHeight;\n      break;\n\n    case 'bottom':\n      rule.from = offset_2;\n      rule.css = { position: 'absolute', top: offset_2 + offsetTop + 'px' };\n      rule.itemHeight = itemHeight;\n      break;\n\n    case 'static':\n      rule.from = 0;\n      rule.css = { position: '', top: '' };\n      rule.itemHeight = 0;\n      break;\n  }\n\n  return rule;\n};\n\n/**\n * Heads up, this function is called on window resize. However even if window\n * has entered new width range it doesn't mean that new responsive styles were\n * allready applied. So we cannot rely on $( window ).width(). What we can rely\n * on are styles that are applied to some predefined element called 'meter'.\n *\n * Html: (our Meter)\n * <div class=\"scroolly\"></div>\n *\n * CSS:\n *\n * .scroolly{\n *      display: none;\n * }\n *\n * media (min-device-width : 320px) and (max-device-width : 480px){\n *      .scroolly{\n *          min-width: 320px;\n *          max-width: 480px;\n *      }\n * }\n * media (min-device-width : 481px) and (max-device-width : 800px){\n *      .scroolly{\n *          min-width: 481px;\n *          max-width: 800px;\n *      }\n * }\n *\n * JS rules:\n *\n * {\n *      minWidth: 320,\n *      maxWidth: 480\n * },\n * {\n *      minWidth: 480,\n *      maxWidth: 800\n * }\n *\n * @returns {Boolean}\n */\nscroolly.onResize = function () {\n  scroolly.winHeight = $(window).height();\n  //        scroolly.docHeight = $(document).height();\n  scroolly.docHeight = scroolly.body.height();\n  scroolly.docMiddle = Math.floor(scroolly.docHeight / 2);\n\n  var needScroll = false;\n\n  for (var id in scroolly.scrollLayout) {\n    // cycling through all visual elements that should react\n    // to scrolling and resizing\n    var item = scroolly.scrollLayout[id],\n      rule,\n      checkin,\n      source;\n    for (var i in item.rules) {\n      rule = item.rules[i];\n      checkin = scroolly.isRuleInActiveWidthRange(rule);\n      needScroll |= checkin;\n      if (checkin && rule.from === undefined) {\n        $(item.element).css('position', '');\n        $(item.element).css('top', '');\n        if (rule.bottomContainer) {\n          rule.bottomContainer.css('margin-top', '');\n        }\n        // item entered new range and should adapt\n        source = scroolly._default(rule, 'source');\n        if ('sticky' === source) {\n          item.rules[i] = scroolly.processStickyItemRange(item.element, rule);\n        }\n      }\n    }\n  }\n  if (needScroll) {\n    // dark magick here do not touch this useless string\n    scroolly.scrollLayout = scroolly.scrollLayout;\n    setTimeout(function () {\n      scroolly.onScroll(true);\n    }, 0);\n    //            scroolly.onScroll();\n  }\n  return true;\n};\n\n/**\n * Helper to get progress values for onScroll handlers\n * @param {integer} offset\n * @param {integer} length\n * @returns {object} progress metrics\n */\nscroolly.getProgress = function (offset, length) {\n  var relative = offset / length;\n  return {\n    offset: offset,\n    length: length,\n    relative: relative,\n    left: length - offset,\n    leftRelative: 1 - relative,\n  };\n};\n\n/**\n * Get transition float value  based on start, stop and progress values\n * @param {number} start\n * @param {number} stop\n * @param {float} progress\n * @returns {Number}\n */\nscroolly.getTransitionFloatValue = function (start, stop, progress) {\n  if (progress <= 0) {\n    return start;\n  }\n\n  if (progress >= 1) {\n    return stop;\n  }\n\n  return start + (stop - start) * progress;\n};\n\n/**\n * Get transition integer value  based on start, stop and progress values\n * @param {number} start\n * @param {number} stop\n * @param {float} progress\n * @returns {Number}\n */\nscroolly.getTransitionIntValue = function (start, stop, progress) {\n  return Math.round(scroolly.getTransitionFloatValue(start, stop, progress));\n};\n\n/**\n * Get [R, G, B] array of integers for provided '#RRGGBB' or '#RGB' value\n * @param {type} color\n * @returns {Array}\n */\nscroolly.hashColor2rgb = function (color) {\n  var m = color.match(/^#([0-9a-f]{3})$/i);\n  if (m) {\n    // in three-character format, each value is multiplied by 0x11 to give an\n    // even scale from 0x00 to 0xff\n    return [\n      parseInt(m[1].charAt(0), 16) * 0x11,\n      parseInt(m[1].charAt(1), 16) * 0x11,\n      parseInt(m[1].charAt(2), 16) * 0x11,\n    ];\n  } else {\n    m = color.match(/^#([0-9a-f]{6})$/i);\n    if (m) {\n      return [\n        parseInt(m[1].substr(0, 2), 16),\n        parseInt(m[1].substr(2, 2), 16),\n        parseInt(m[1].substr(4, 2), 16),\n      ];\n    }\n  }\n  return [0, 0, 0];\n};\n\n/**\n * Get '#RRGGBB' value for provided R, G, B integer values\n * @param {integer} r\n * @param {integer} g\n * @param {integer} b\n * @returns {string} #RRGGBB\n */\nscroolly.rgb2HashColor = function (r, g, b) {\n  var res = '#',\n    c,\n    hex;\n  for (var i in arguments) {\n    c = arguments[i];\n    hex = c.toString(16);\n\n    if (c < 16) {\n      hex = '0' + hex;\n    }\n\n    res += hex;\n  }\n\n  return res;\n};\n\n/**\n * Get transition color value  based on start, stop and progress values\n * @param {cssColor} start\n * @param {cssColor} stop\n * @param {float} progress\n * @returns {Number}\n */\nscroolly.getTransitionColorValue = function (start, stop, progress) {\n  if (progress <= 0) {\n    return start;\n  }\n\n  if (progress >= 1) {\n    return stop;\n  }\n\n  var startRGB = scroolly.hashColor2rgb(start),\n    stopRGB = scroolly.hashColor2rgb(stop),\n    r = scroolly.getTransitionIntValue(startRGB[0], stopRGB[0], progress),\n    g = scroolly.getTransitionIntValue(startRGB[1], stopRGB[1], progress),\n    b = scroolly.getTransitionIntValue(startRGB[2], stopRGB[2], progress);\n\n  return scroolly.rgb2HashColor(r, g, b);\n};\n\n/**\n * Get transition css value  based on start, stop and progress values\n * @param {cssColor} start\n * @param {cssColor} stop\n * @param {float} progress\n * @returns {Number}\n */\nscroolly.getTransitionValue = function (start, stop, progress) {\n  if (progress <= 0) {\n    return start;\n  }\n\n  if (progress >= 1) {\n    return stop;\n  }\n\n  var called = 0;\n  if (scroolly._isNumber(start) && scroolly._isNumber(stop)) {\n    return scroolly.getTransitionFloatValue(start, stop, progress);\n  }\n\n  var re = /(\\d*\\.\\d+)|(\\d+)|(#[0-9a-f]{6})|(#[0-9a-f]{3})/gi,\n    stops = ('' + stop).match(re);\n\n  return ('' + start).replace(re, function (\n    value,\n    float,\n    int,\n    color6,\n    color3\n  ) {\n    //            console.dir({'replace callback args':arguments, stops: stops, called: called});\n    var currentStop = stops[called];\n\n    called++;\n    if (int && int.length) {\n      return /\\d*\\.\\d+/.test(currentStop)\n        ? scroolly.getTransitionFloatValue(\n            parseFloat(value),\n            parseFloat(currentStop),\n            progress\n          )\n        : scroolly.getTransitionIntValue(\n            parseInt(value),\n            parseInt(currentStop),\n            progress\n          );\n    }\n\n    if (float && float.length) {\n      return scroolly.getTransitionFloatValue(\n        parseFloat(value),\n        parseFloat(currentStop),\n        progress\n      );\n    }\n\n    if ((color6 && color6.length) || (color3 && color3.length)) {\n      return scroolly.getTransitionColorValue(value, currentStop, progress);\n    }\n\n    return value;\n  });\n};\n\n/**\n * Function that is called while sccrolls.\n * @param {boolean} force description\n * @returns {boolean}\n */\nscroolly.onScroll = function (force) {\n  //        var scrollPos = $(document).scrollTop(); // Y-coord that is checked against fromY & toY\n  var scrollPos = scroolly.body.scrollTop(); // Y-coord that is checked against fromY & toY\n\n  if (!force && scrollPos === scroolly.scrollTop) {\n    return false;\n  }\n\n  var prevPos = scroolly.scrollTop,\n    prevDirection = scroolly.direction;\n\n  scroolly.scrollTop = scrollPos; // Y-coord that is checked against fromY & toY\n  scroolly.scrollBottom = scrollPos + scroolly.winHeight;\n  scroolly.scrollCenter = scrollPos + Math.floor(scroolly.winHeight / 2);\n  scroolly.direction = scrollPos - prevPos;\n\n  var directionChanged = !(\n      scroolly.direction === prevDirection ||\n      (scroolly.direction < 0 && prevDirection < 0) ||\n      (scroolly.direction > 0 && prevDirection > 0)\n    ),\n    item,\n    totalRules,\n    checkedIn,\n    checkedOut,\n    active,\n    id,\n    i,\n    l,\n    j,\n    rule,\n    fromX,\n    toX,\n    container,\n    $bottomContainer,\n    mode,\n    itemHeight;\n\n  for (id in scroolly.scrollLayout) {\n    // cycling through all visual elements that should react\n    // to scrolling and resizing\n    item = scroolly.scrollLayout[id];\n    totalRules = item.rules.length;\n    checkedIn = [];\n    checkedOut = [];\n    active = [];\n\n    for (i = 0; i < totalRules; i++) {\n      rule = item.rules[i];\n      fromX = scroolly._default(rule, 'minWidth', 0);\n      toX = scroolly._default(rule, 'maxWidth', 'infinity');\n\n      container = item.container === 'self' ? item.element : item.container;\n\n      rule.checkin = scroolly.isRuleActive(rule, item.element, container);\n      rule['class'] =\n        rule['class'] ||\n        'scroll-pos-' + rule.alias + ' window-width-' + fromX + '-to-' + toX;\n      if (rule.checkin) {\n        active.push(i);\n        if (!rule.isActive) {\n          rule.isActive = true;\n          checkedIn.push(i);\n        }\n      } else if (rule.isActive) {\n        rule.isActive = false;\n        checkedOut.push(i);\n      }\n      item.rules[i] = rule;\n    }\n\n    for (j = 0; j < checkedOut.length; j++) {\n      i = checkedOut[j];\n      rule = item.rules[i];\n      item.element.removeClass(rule['class']);\n      if (rule.cssOnScroll) {\n        l = rule.length || 0;\n        rule.cssOnScroll(item.element, scrollPos > prevPos ? l : 0, l, rule);\n      }\n      if (rule.onScroll) {\n        l = rule.length || 0;\n        rule.onScroll(item.element, scrollPos > prevPos ? l : 0, l, rule);\n      }\n      if (rule.onCheckOut) {\n        rule.onCheckOut(item.element, rule);\n      }\n      if (rule.onTopOut && scrollPos < prevPos) {\n        rule.onTopOut(item.element, rule);\n      } else if (rule.onBottomOut && scrollPos > prevPos) {\n        rule.onBottomOut(item.element, rule);\n      }\n    }\n\n    for (j = 0; j < checkedIn.length; j++) {\n      i = checkedIn[j];\n      rule = item.rules[i];\n\n      if (rule.css) {\n        item.element.css(scroolly.extendCssWithPrefix(rule.css));\n      }\n\n      if (rule.addClass) {\n        item.element.addClass(rule.addClass);\n      }\n\n      if (rule.removeClass) {\n        item.element.removeClass(rule.removeClass);\n      }\n      item.element.addClass(rule['class']);\n\n      $bottomContainer = scroolly._default(rule, 'bottomContainer');\n      mode = scroolly._default(rule, 'mode');\n      itemHeight = scroolly._default(rule, 'itemHeight');\n\n      if ($bottomContainer && mode && itemHeight) {\n        $bottomContainer.css(mode + '-top', itemHeight + 'px');\n      }\n\n      if (rule.onCheckIn) {\n        rule.onCheckIn(item.element, rule);\n      }\n\n      if (rule.onTopIn && scrollPos > prevPos) {\n        rule.onTopIn(item.element, rule);\n      } else if (rule.onBottomIn && scrollPos < prevPos) {\n        rule.onBottomIn(item.element, rule);\n      }\n\n      rule.length = rule.checkin.length;\n    }\n\n    for (j = 0; j < active.length; j++) {\n      i = active[j];\n      rule = item.rules[i];\n\n      if (rule.cssOnScroll) {\n        rule.cssOnScroll(\n          item.element,\n          rule.checkin.offset,\n          rule.checkin.length,\n          rule\n        );\n      }\n\n      if (rule.onScroll) {\n        rule.onScroll(\n          item.element,\n          rule.checkin.offset,\n          rule.checkin.length,\n          rule\n        );\n      }\n\n      if (directionChanged && rule.onDirectionChanged) {\n        rule.onDirectionChanged(item.element, scroolly.direction, rule);\n      }\n    }\n    scroolly.scrollLayout[id] = item;\n  }\n};\n\n//Will be called once (when scroolly gets initialized).\nscroolly.detectCSSPrefix = function () {\n  //Only relevant prefixes. May be extended.\n  //Could be dangerous if there will ever be a CSS property which actually starts with \"ms\". Don't hope so.\n  var rxPrefixes = /^(?:O|Moz|webkit|ms)|(?:-(?:o|moz|webkit|ms)-)/;\n\n  //Detect prefix for current browser by finding the first property using a prefix.\n  if (!window.getComputedStyle) {\n    return;\n  }\n\n  var style = window.getComputedStyle(document.body, null);\n\n  for (var k in style) {\n    //We check the key and if the key is a number, we check the value as well, because safari's getComputedStyle returns some weird array-like thingy.\n    scroolly.theCSSPrefix =\n      k.match(rxPrefixes) || (+k === k && style[k].match(rxPrefixes));\n\n    if (scroolly.theCSSPrefix) {\n      break;\n    }\n  }\n\n  //Did we even detect a prefix?\n  if (!scroolly.theCSSPrefix) {\n    scroolly.theCSSPrefix = scroolly.theDashedCSSPrefix = '';\n\n    return;\n  }\n\n  scroolly.theCSSPrefix = scroolly.theCSSPrefix[0];\n\n  //We could have detected either a dashed prefix or this camelCaseish-inconsistent stuff.\n  if (scroolly.theCSSPrefix.slice(0, 1) === '-') {\n    scroolly.theDashedCSSPrefix = scroolly.theCSSPrefix;\n\n    //There's no logic behind these. Need a look up.\n    scroolly.theCSSPrefix = {\n      '-webkit-': 'webkit',\n      '-moz-': 'Moz',\n      '-ms-': 'ms',\n      '-o-': 'O',\n    }[scroolly.theCSSPrefix];\n  } else {\n    scroolly.theDashedCSSPrefix =\n      '-' + scroolly.theCSSPrefix.toLowerCase() + '-';\n  }\n};\n\nscroolly.cssPrefix = function (key) {\n  return scroolly.theDashedCSSPrefix + key;\n};\n\nscroolly.extendCssWithPrefix = function (cssObj) {\n  var cssExt = {},\n    prop,\n    re,\n    m,\n    newProp,\n    val;\n\n  for (prop in cssObj) {\n    re = /^-(moz-|webkit-|o-|ms-)?/i;\n    m = prop.match(re);\n    newProp = prop.slice(1);\n    //            console.dir({m: m});\n    if (m && !m[1]) {\n      val = cssObj[prop];\n      cssExt[newProp] = val;\n      cssExt[scroolly.cssPrefix(newProp)] = val;\n      delete cssObj[prop];\n    }\n  }\n\n  $.extend(cssObj, cssExt);\n\n  return cssObj;\n};\n\nscroolly.now =\n  Date.now ||\n  function () {\n    return +new Date();\n  };\n\nscroolly.getRAF = function () {\n  var requestAnimFrame =\n      window.requestAnimationFrame ||\n      window[scroolly.theCSSPrefix.toLowerCase() + 'RequestAnimationFrame'],\n    lastTime = scroolly.now();\n\n  if ((false && scroolly.isMobile) || !requestAnimFrame) {\n    requestAnimFrame = function (callback) {\n      //How long did it take to render?\n      var deltaTime = scroolly.now() - lastTime,\n        delay = Math.max(0, 1000 / 60 - deltaTime);\n\n      return window.setTimeout(function () {\n        lastTime = scroolly.now();\n        //        scroolly.timesCalled++;\n        //        scroolly.x.text(scroolly.timesCalled);\n        callback();\n      }, delay);\n    };\n  }\n\n  return requestAnimFrame;\n};\n\nscroolly.getCAF = function () {\n  var cancelAnimFrame =\n    window.cancelAnimationFrame ||\n    window[scroolly.theCSSPrefix.toLowerCase() + 'CancelAnimationFrame'];\n\n  if (scroolly.isMobile || !cancelAnimFrame) {\n    cancelAnimFrame = function (timeout) {\n      return window.clearTimeout(timeout);\n    };\n  }\n\n  return cancelAnimFrame;\n};\n\nscroolly.animLoop = function () {\n  scroolly.onScroll();\n  scroolly.animFrame = window.requestAnimFrame(scroolly.animLoop);\n};\n\nscroolly.init = function (options) {\n  if (scroolly.isInitialized) {\n    return false;\n  }\n  $.extend(scroolly.options, options);\n  scroolly.isMobile = scroolly._default(\n    scroolly.options,\n    'isMobile',\n    /Android|iPhone|iPad|iPod|BlackBerry/i.test(\n      navigator.userAgent || navigator.vendor || window.opera\n    )\n  );\n  scroolly.detectCSSPrefix();\n  scroolly.body = $(scroolly.options.body);\n  window.requestAnimFrame = scroolly.getRAF();\n  window.cancelAnimFrame = scroolly.getCAF();\n\n  scroolly.timesCalled = 0;\n  $(document).ready(function () {\n    $(window).resize(scroolly.onResize).resize();\n    //            scroolly.body.scroll(function(){scroolly.onScroll(true);}).scroll();\n    scroolly.animLoop();\n  });\n  scroolly.isInitialized = true;\n};\n\nscroolly.destroy = function () {\n  window.cancelAnimFrame(scroolly.animFrame);\n};\n\nscroolly.factorySticky = function ($element, params, id) {\n  id = id || $element[0].tagName + '_' + scroolly.getScrollLayoutLength();\n  return scroolly.stickItemXY(\n    id,\n    $element,\n    params instanceof Array ? params : [params]\n  )\n    ? id\n    : false;\n};\n\n\n$.scroolly = scroolly;\n\n$.fn.scroolly = function (rules, $container, id) {\n  scroolly.factory(this, rules, $container, id);\n  return this;\n};\n\n/**\n * params = [widthRange1, widthRange2, ... , widthRangeN]\n *\n * widthRangeN = {\n *      $bottomContainer: $(DOMnode),   // - container that defines bottom container\n *      mode: 'margin'||'padding', // - defines the way element height will be compensated\n *      minWidth: 0,\n *      maxWidth: 'infinity',\n *      static: false // - whether element should be fixed allways for current width range\n * }\n *\n *\n * @param {type} params\n * @param {type} id\n * @returns {Boolean|String}\n */\n$.fn.scroollySticky = function (params, id) {\n  scroolly.init();\n\n  if (!this.length) {\n    return false;\n  }\n\n  return scroolly.factorySticky(this, params, id);\n};\n\nexport default scroolly"],"names":["scroolly","options","timeout","meter","$","body","document","theCSSPrefix","theDashedCSSPrefix","isMobile","isInitialized","animFrame","direction","scrollTop","scrollCenter","scrollBottom","docHeight","docMiddle","winHeight","window","height","val","_typeof","Array","Number","String","obj","key","defaultValue","undefined","parts","split","_isObject","_isArray","part","root","i","boundry","strings","coordRel","parsedCoordRel","parseCoord","coordVP","anchor","coord","reOffsetStr","reOffset","RegExp","mA","match","mO","subject","offsets","mO2","sign","offset","offsetSubject","length","parseInt","push","original","$element","$container","_isString","o","subjectOffset","relativeHeight","subjectCoord","$subject","subjectHeight","outerHeight","subjectTop","top","subjectBottom","subjectCenter","Math","floor","ceil","coords","calculateCoord","rule","minWidthScrolly","maxWidthScrolly","fromX","_default","toX","width","css","isRuleInActiveWidthRange","ruleDirection","scrollDirection","fromY","toY","toTop","cmpCoords","toBottom","Object","keys","scrollLayout","map","id","rules","fromCss","toCss","cssOnScroll","element","fromProp","toProp","progress","property","getTransitionValue","extendCssWithPrefix","_isNumber","parseCoords","from","to","each","clonedRule","clonedRules","$con","j","extend","addItem","this","item","concat","container","init","tagName","getScrollLayoutLength","params","stickItemXY","xRange","$bottomContainer","mode","offsetTop","offsetBottom","minWidth","maxWidth","isStatic","x","next","parent","source","alias","bottomContainer","itemHeight","bottomContainerHeight","offset_1","round","offset_2","position","needScroll","checkin","processStickyItemRange","setTimeout","onScroll","relative","left","leftRelative","start","stop","getTransitionFloatValue","color","m","charAt","substr","r","g","b","c","hex","res","arguments","toString","startRGB","hashColor2rgb","stopRGB","getTransitionIntValue","rgb2HashColor","called","re","stops","replace","value","float","int","color6","color3","currentStop","test","parseFloat","getTransitionColorValue","force","scrollPos","prevPos","prevDirection","totalRules","checkedIn","checkedOut","active","l","directionChanged","isRuleActive","isActive","removeClass","onCheckOut","onTopOut","onBottomOut","addClass","onCheckIn","onTopIn","onBottomIn","onDirectionChanged","rxPrefixes","getComputedStyle","style","k","slice","toLowerCase","cssObj","prop","newProp","cssExt","cssPrefix","now","Date","getRAF","requestAnimFrame","requestAnimationFrame","lastTime","callback","deltaTime","delay","max","getCAF","cancelAnimFrame","cancelAnimationFrame","clearTimeout","animLoop","navigator","userAgent","vendor","opera","detectCSSPrefix","timesCalled","ready","resize","onResize","destroy","factorySticky","fn","factory","scroollySticky"],"mappings":"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"}